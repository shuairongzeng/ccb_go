# Project-Scoped Daemon Isolation - Solution Design

> Generated by all-plan collaborative design process (Codex-led)

## Overview

**Goal**: Enforce strict per-directory daemon isolation (anchored by `.ccb_config` in the current working directory) and improve IPC/process stability without breaking current CLI workflows.

**Readiness Score**: 61/100

**Generated**: 2026-01-20

---

## Requirements Summary

### Problem Statement
Current caskd/gaskd/oaskd/laskd IPC is unstable and risks cross-project routing. The system must isolate communication strictly by each current-directory anchor (`.ccb_config` directory) and improve daemon stability.

### Scope
In scope:
- Project anchor resolution based on current directory `.ccb_config` only (no ancestor inheritance).
- Per-project daemon runtime (state/log/lock) and project-scoped locking.
- Request validation using `project_id` and `project_root`.
- Unified retries, stale state cleanup, heartbeat liveness checks.
- Graceful shutdown, startup serialization, crash recovery, and ccb-managed daemon lifecycle (resident while `ccb` runs).
- Legacy migration and compatibility flags.
- Multi-project stress tests and recovery tests.

Out of scope (phase 2 or later):
- Switching default transport to Unix sockets/Named Pipes (opt-in only).
- Deep changes to provider-specific log parsing logic.

### Success Criteria
- [ ] 0 cross-project routing events under multi-project concurrency tests.
- [ ] >99% successful request completion across 1,000 requests with autostart enabled.
- [ ] Daemon crash recovery completes within 3-5 seconds without manual cleanup.
- [ ] Daemon stays resident while `ccb` is running and exits within 5 seconds after `ccb` exits.

### Constraints
- Cross-platform support (Linux/macOS/Windows/WSL).
- Preserve existing CLI UX where possible.
- No ancestor anchor inheritance; subdirectories must be treated as independent project roots.
- If a parent directory has `.ccb_config`, auto-create is blocked and user must create a local `.ccb_config` manually.
- Only one `ccb` instance may run per directory; a second instance must fail fast with a clear error.

### Assumptions
- `.ccb_config` exists in each working directory used with `ccb` (nested anchors allowed) and is writable by the user.
- Users accept per-project daemon processes tied to the `ccb` lifecycle (idle timeout disabled when launched by `ccb`).
- Cache directory (`~/.cache/ccb`) is available for runtime storage by default.

---

## Architecture

### Approach
- **Anchor-based isolation**: resolve `project_root` from the current directory `.ccb_config` only (no upward traversal) and compute `project_id` (SHA256, truncated to 16 hex chars for paths).
- **Per-project daemons**: each project runs its own caskd/gaskd/oaskd/laskd instances.
- **Project-scoped runtime**: default run_dir is `~/.cache/ccb/projects/<project_id>/<provider>/`; optional project-local mode uses `<project_root>/.ccb_config/run/<provider>/` when `CCB_RUN_DIR_MODE=project` or cache is not writable.
- **Validation handshake**: state file includes `project_id`, `project_root`, `protocol_version`, `pid`, `started_at`, and `heartbeat` (timestamp + monotonic counter). Client rejects mismatched state and server rejects mismatched requests.
- **Registry**: keep global registry (`~/.ccb/run/`) but enforce strict `project_id` matching.
- **Lifecycle**: disable idle timeout for daemons launched by `ccb`; track `parent_pid` and shut down when `ccb` exits.

### Key Components
- **Current-Dir Anchor Resolver**: returns `project_root` and `project_id` only when `.ccb_config` exists in the current working directory.
- **Project-Scoped Runtime (askd_runtime)**: computes run_dir and state/log paths per project.
- **Daemon Lifecycle Manager**: startup lock, graceful shutdown, heartbeat updates.
- **Request Guardrails**: per-request project_id validation, optional ACK + dedup.
- **Migration Handler**: detects legacy state and migrates or honors legacy mode.

### Data Flow
1. CLI checks `.ccb_config` in the current working directory; if missing and no parent anchor exists, auto-create; if a parent anchor exists, error and instruct manual creation.
2. CLI sets `project_root = cwd` and computes `project_id`.
3. CLI computes project run_dir, reads state file, validates `project_id`/`project_root`.
4. If invalid or stale, CLI cleans state and autostarts project-scoped daemon (with `parent_pid` set to the `ccb` process).
5. CLI sends request with `project_id` (and protocol version); daemon validates before enqueue.
6. Daemon processes request and returns response; failures are logged to dead-letter file.
7. On `ccb` exit, daemons receive shutdown signal or detect `parent_pid` exit and shut down.
8. If another `ccb` is already running in the same directory, new `ccb` exits with an error (single-instance enforcement).

---

## Implementation Plan

### Step 1: Anchor Resolution + Session Lookup
- **Actions**: add shared helper to resolve `.ccb_config` in the current directory only; remove parent-anchor fallback; update `ccb` init to auto-create only when no parent anchor exists and otherwise error with guidance to create local `.ccb_config`; update `session_utils.find_project_session_file` and `claude_session_resolver` to use current-dir anchor only.
- **Deliverables**: unified project_root/project_id helper (cwd-only); session lookup anchored to current directory `.ccb_config`.
- **Dependencies**: none.

### Step 2: Project-Scoped Runtime + Locks
- **Actions**: extend `askd_runtime` to compute run_dir per project; update daemon state/log paths; update `ProviderLock` to include project_id; ensure atomic state writes.
- **Deliverables**: per-project run_dir paths; project-scoped lock implementation.
- **Dependencies**: Step 1.

### Step 3: State Validation + Routing Guardrails
- **Actions**: add `project_id`, `project_root`, `protocol_version` to state file; include `project_id` in request payloads; reject mismatches on client and server.
- **Deliverables**: state schema update + validation logic.
- **Dependencies**: Step 2.

### Step 4: Daemon Lifecycle (Startup/Shutdown)
- **Actions**: add startup lock timeout (default 5s); add signal handlers (SIGTERM/SIGINT) to stop intake and drain in-flight requests; add heartbeat update loop (5s) with stale threshold (15s, configurable via `CCB_HEARTBEAT_STALE_S`); when launched by `ccb`, disable idle timeout and record `parent_pid` in state; add parent-pid watcher to exit when `ccb` terminates; send explicit shutdown on `ccb` exit as a best-effort fallback.
- **Deliverables**: stable startup/shutdown behavior with liveness detection.
- **Dependencies**: Steps 2-3.

### Step 5: Reliability Hardening
- **Actions**: unify retry/backoff across cask/gask/oask/lask; delete stale state on failed ping; optional ACK + dedup (short TTL); dead-letter logging with retention (e.g., cap 1,000 entries).
- **Deliverables**: consistent request reliability behavior and failure visibility.
- **Dependencies**: Steps 3-4.

### Step 6: Migration + Backward Compatibility
- **Actions**: detect legacy global state files; honor `CCB_LEGACY_GLOBAL_DAEMON=1`; add one-time migration warning marker (`~/.cache/ccb/.migration_warned`); implement `ccb migrate` (all providers, optional `--provider`); if parent `.ccb_config` exists and current dir has none, error and instruct manual creation of local `.ccb_config`.
- **Deliverables**: migration path with legacy fallback.
- **Dependencies**: Steps 1-5.

### Step 7: Tests + Benchmarks
- **Actions**: multi-project concurrency tests; stale state cleanup test; daemon crash recovery test; stress test (1,000+ requests).
- **Deliverables**: integration tests and benchmark scripts.
- **Dependencies**: Steps 1-6.

---

## Technical Considerations

- **Project ID paths**: use truncated SHA256 (first 16 hex chars) to avoid long paths.
- **Protocol versioning**: bump on any breaking change to state file schema or wire format; start at v1.
- **Transport**: TCP default; optional UDS/Named Pipe in Phase 2 with hashed short names.
- **Permissions/disk full**: fail fast with clear errors; fallback to cache when project-local is not writable.

---

## Risk Management

| Risk | Impact | Likelihood | Mitigation |
|------|--------|------------|------------|
| More daemons = higher resource use | Med | Med | `ccb` lifecycle shutdown + optional idle timeout when not `ccb`-managed |
| Many subdirectories become independent projects | Med | Med | Operator guidance + `ccb` lifecycle shutdown |
| Permission denied or network FS | Med | Med | Cache-based run_dir default + fallback |
| Version mismatch | Med | Low | protocol_version check + clear error |
| Clock skew on heartbeat | Low | Low | Monotonic counter + timestamp |
| Disk full / write failures | Med | Low | Fail fast + clear error; do not start daemon |
| Orphan daemons if `ccb` crashes | Med | Low | parent_pid watcher + shutdown on `ccb` exit |

---

## Acceptance Criteria

- [ ] 0 cross-project routing under multi-project concurrency.
- [ ] >99% success rate over 1,000 requests with autostart.
- [ ] Daemon crash recovery within 3-5 seconds without manual cleanup.

---

## Design Contributors

| CLI | Key Contributions |
|-----|-------------------|
| Codex | Anchor-based routing, compatibility, unified retries |
| Claude | Heartbeat, ACK/dedup, crash recovery, lifecycle hardening |
| Gemini | Lock/sentinel emphasis, project-scoped runtime |
| OpenCode | Hashed project_id paths, dead-letter logging |

---

## Appendix

### Clarification Summary

Readiness Score: 61/100

Dimensions:
- Problem Clarity: 24/30 (Defined)
- Functional Scope: 10/25 (Gap)
- Success Criteria: 18/20 (Defined)
- Constraints: 0/15 (Gap)
- Priority/MVP: 9/10 (Defined)

Assumptions & Gaps:
- Functional Scope: not specified; requires codebase-driven definition.
- Constraints: not specified; assume backward compatibility and cross-platform support (plus current-dir anchor rule).

### Alternative Approaches Considered
- Keep global per-provider daemon with stricter session_key routing only (rejected due to continued cross-project risk).
- Inherit parent `.ccb_config` anchors for subdirectories (rejected per user requirement).
- Switch default IPC to Unix sockets/Named Pipes (deferred to Phase 2 for cross-platform complexity).
